// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// Generate time: 2006-01-02 15:04:05
// versions:
// - protoc-gen-go-grpc v1.0.5
// - protoc             v5.28.0
// source: helloworld/hello.proto

package helloworld

import (
	context "context"
	errors "errors"
	client "github.com/cloudwego/kitex/client"
	serviceinfo "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	server "github.com/frochyzhang/ag-core/ag/ag_kitex/server"
	fx "go.uber.org/fx"
	proto "google.golang.org/protobuf/proto"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = errors.Join()
var _ = proto.Error
var _ = client.Option{}
var _ = streaming.Args{}
var _ = fx.Self()
var _ = serviceinfo.ServiceInfo{}
var _ = server.Server{}

var helloMethods = map[string]serviceinfo.MethodInfo{
	"CreateHello": serviceinfo.NewMethodInfo(
		createHelloHandler,
		newCreateHelloHello1RequestArgs,
		newCreateHelloHello1ReplyResult,
		false,
		serviceinfo.WithStreamingMode(serviceinfo.StreamingUnary),
	),
}

func Register_Hello_GRPCServer(srv HelloServer) server.Option {
	return server.WithServiceRegistrar(&server.ServiceRegistrar{
		ServiceInfo: NewHelloServiceInfo(),
		Handler:     srv,
	})
}

// NewHelloServiceInfo creates a new ServiceInfo containing all methods
func NewHelloServiceInfo() *serviceinfo.ServiceInfo {
	return newHelloServiceInfo(false, true, true)
}

// NewHelloServiceInfoForClient creates a new ServiceInfo containing non-streaming methods
func NewHelloServiceInfoForClient() *serviceinfo.ServiceInfo {
	return newHelloServiceInfo(false, false, true)
}
func NewHelloServiceInfoForStreamClient() *serviceinfo.ServiceInfo {
	return newHelloServiceInfo(true, true, false)
}

func newHelloServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *serviceinfo.ServiceInfo {
	serviceName := "Hello"
	handlerType := (*HelloServer)(nil)
	methods := map[string]serviceinfo.MethodInfo{}
	for name, m := range helloMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "helloworld",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &serviceinfo.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    serviceinfo.Protobuf,
		KiteXGenVersion: "v1.0.5",
		Extra:           extra,
	}
	return svcInfo
}

func createHelloHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(Hello1Request)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(HelloServer).CreateHello(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateHelloHello1RequestArgs:
		success, err := handler.(HelloServer).CreateHello(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateHelloHello1ReplyResult)
		realResult.Success = success
		return nil
	default:
		return errors.New("invalid message type for service method handler")
	}
}
func newCreateHelloHello1RequestArgs() interface{} {
	return &CreateHelloHello1RequestArgs{}
}

func newCreateHelloHello1ReplyResult() interface{} {
	return &CreateHelloHello1ReplyResult{}
}

type CreateHelloHello1RequestArgs struct {
	Req *Hello1Request
}

func (p *CreateHelloHello1RequestArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateHelloHello1RequestArgs) Unmarshal(in []byte) error {
	msg := new(Hello1Request)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateHelloHello1RequestArgs_Req_DEFAULT *Hello1Request

func (p *CreateHelloHello1RequestArgs) GetReq() *Hello1Request {
	if !p.IsSetReq() {
		return CreateHelloHello1RequestArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateHelloHello1RequestArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateHelloHello1RequestArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateHelloHello1ReplyResult struct {
	Success *Hello1Reply
}

var CreateHelloHello1ReplyResult_Success_DEFAULT *Hello1Reply

func (p *CreateHelloHello1ReplyResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateHelloHello1ReplyResult) Unmarshal(in []byte) error {
	msg := new(Hello1Reply)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateHelloHello1ReplyResult) GetSuccess() *Hello1Reply {
	if !p.IsSetSuccess() {
		return CreateHelloHello1ReplyResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateHelloHello1ReplyResult) SetSuccess(x interface{}) {
	p.Success = x.(*Hello1Reply)
}

func (p *CreateHelloHello1ReplyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateHelloHello1ReplyResult) GetResult() interface{} {
	return p.Success
}

type kHelloClient struct {
	c client.Client
}

func newHelloServiceClient(c client.Client) *kHelloClient {
	return &kHelloClient{
		c: c,
	}
}

func (p *kHelloClient) CreateHello(ctx context.Context, Req *Hello1Request) (r *Hello1Reply, err error) {
	var _args CreateHelloHello1RequestArgs
	_args.Req = Req
	var _result CreateHelloHello1ReplyResult
	if err = p.c.Call(ctx, "CreateHello", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

var FxHelloGRPCModule = fx.Module("fx_Hello_GRPC",
	fx.Provide(
		fx.Annotate(
			Register_Hello_GRPCServer,
			fx.ResultTags(`group:"ag_kitex_server_registrars"`),
		),
	),
)
