// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Generate time: 2006-01-02 15:04:05
// versions:
// - protoc-gen-go-http v1.0.7
// - protoc             v5.28.0
// source: helloworld/hello.proto

package helloworld

import (
	context "context"
	app "github.com/cloudwego/hertz/pkg/app"
	config "github.com/cloudwego/hertz/pkg/common/config"
	consts "github.com/cloudwego/hertz/pkg/protocol/consts"
	client "github.com/frochyzhang/ag-core/ag/ag_hertz/client"
	server "github.com/frochyzhang/ag-core/ag/ag_hertz/server"
	fx "go.uber.org/fx"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = app.FS{}
var _ = server.Server{}
var _ = consts.StatusOK
var _ = client.Client{}
var _ = fx.Self()
var _ = config.RequestOption{}

const OperationHelloCreateHello = "/helloworld.Hello/CreateHello"

func Register_Hello_CreateHello_HTTPServer(srv HelloServer) server.Option {
	return server.WithRoute(&server.Route{
		HttpMethod:   "POST",
		RelativePath: "/hello/:Name",
		Handlers:     append(make([]app.HandlerFunc, 0), _Hello_CreateHello0_HTTP_Handler(srv)),
	})
}

func _Hello_CreateHello0_HTTP_Handler(srv HelloServer) func(ctx context.Context, c *app.RequestContext) {
	return func(ctx context.Context, c *app.RequestContext) {
		var in = new(Hello1Request)
		if err := c.BindByContentType(in); err != nil {
			c.String(consts.StatusBadRequest, err.Error())
			return
		}
		if err := c.BindQuery(in); err != nil {
			c.String(consts.StatusBadRequest, err.Error())
			return
		}
		if err := c.BindPath(in); err != nil {
			c.String(consts.StatusBadRequest, err.Error())
			return
		}
		reply, err := srv.CreateHello(ctx, in)
		if err != nil {
			c.String(consts.StatusInternalServerError, err.Error())
			return
		}
		c.JSON(consts.StatusOK, reply)
	}
}

type HelloHTTPClient interface {
	CreateHello(ctx context.Context, req *Hello1Request, opts ...config.RequestOption) (rsp *Hello1Reply, err error)
}

type HelloHTTPClientImpl struct {
	cc *client.Client
}

func NewHelloHTTPClient(client *client.Client) HelloHTTPClient {
	return &HelloHTTPClientImpl{client}
}

func (c *HelloHTTPClientImpl) CreateHello(ctx context.Context, in *Hello1Request, opts ...config.RequestOption) (*Hello1Reply, error) {
	var out Hello1Reply
	path := "/hello/:Name"
	pathVars := make(map[string]string)

	pathVars["Name"] = in.GetName()
	//	path := binding.EncodeURL(pattern, in, false)
	//	opts = append(opts, http.Operation(OperationHelloCreateHello))
	//	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, pathVars, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

var FxHelloHTTPModule = fx.Module("fx_Hello_HTTP",
	fx.Provide(

		fx.Annotate(
			Register_Hello_CreateHello_HTTPServer,
			fx.ResultTags(`group:"hertz_router_options"`),
		),
	),
)
